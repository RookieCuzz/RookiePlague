# 染疫判断流程

## 总体架构

```
定时任务（主线程）
  ↓
启动异步任务（AsyncTask）
  ↓
异步统计区块内动物数量
  ↓
异步计算每只动物的染疫概率
  ├─ 使用 PlagueFormulaService.calculate()
  ├─ 使用配置的 baseChance、speciesFactor 等
  └─ 根据概率随机决定是否染疫
  ↓
记录需要染疫的动物 UUID 列表
  ↓
切回主线程（Bukkit.getScheduler().runTask）
  ↓
验证实体仍然存在且有效
  ↓
应用染疫状态
  ├─ AnimalDataService.setInfected()
  ├─ AnimalDataService.setInfectedTime()
  └─ 应用药水效果（可选）
  ↓
记录日志
```

## 实现步骤

### 1. 数量统计（异步执行）

先拿到 loaded chunks，再用 `Chunk#getLoadLevel()` 精确筛出"正在 tick（含实体）"的区块，然后统计区块内实体。

**异步读取代码示例：**

```java
// 在异步任务中执行
for (Chunk chunk : world.getLoadedChunks()) {
    // 只处理正在 tick 的区块
    if (chunk.getLoadLevel() != Chunk.LoadLevel.ENTITY_TICKING) continue;
    if (!chunk.isEntitiesLoaded()) continue;

    // 统计各类动物数量
    Map<EntityType, Integer> animalCounts = new HashMap<>();
    List<Animals> animalsList = new ArrayList<>();
    
    for (Entity entity : chunk.getEntities()) {
        if (entity instanceof Animals animal) {
            EntityType type = entity.getType();
            animalCounts.put(type, animalCounts.getOrDefault(type, 0) + 1);
            animalsList.add(animal);
        }
    }
    
    // 处理该区块的染疫逻辑
    processChunkInfection(chunk, animalCounts, animalsList);
}
```

### 2. 染疫概率计算（异步执行）

```java
private void processChunkInfection(Chunk chunk, 
                                   Map<EntityType, Integer> counts,
                                   List<Animals> animals) {
    List<UUID> toInfect = new ArrayList<>();
    
    for (Animals animal : animals) {
        // 检查动物配置
        AnimalConfig config = getAnimalConfig(animal.getType());
        if (config == null) continue;
        
        // 检查是否已染疫
        if (isAlreadyInfected(animal)) continue;
        
        // 构建计算变量
        Map<String, Double> variables = buildVariables(animal, config, counts);
        
        // 计算染疫概率
        double probability = plagueFormulaService.calculate(variables);
        
        // 根据概率随机决定
        if (Math.random() < probability) {
            toInfect.add(animal.getUniqueId());
        }
    }
    
    // 切回主线程应用染疫状态
    if (!toInfect.isEmpty()) {
        applyInfectionOnMainThread(toInfect);
    }
}
```

### 3. 应用染疫状态（主线程执行）

```java
private void applyInfectionOnMainThread(List<UUID> uuids) {
    Bukkit.getScheduler().runTask(plugin, () -> {
        for (UUID uuid : uuids) {
            // 验证实体仍然存在
            Entity entity = Bukkit.getEntity(uuid);
            if (entity == null || !entity.isValid()) continue;
            if (!(entity instanceof Animals animal)) continue;
            
            // 再次检查是否已染疫（防止并发问题）
            if (animalDataService.isInfected(animal)) continue;
            
            // 应用染疫状态
            animalDataService.setInfected(animal, true);
            animalDataService.setInfectedTime(animal, System.currentTimeMillis());
            
            // 可选：应用视觉效果
            applyInfectionEffects(animal);
            
            // 记录日志
            loggerService.info("动物染疫: %s (%s)", 
                animal.getType(), animal.getUniqueId());
        }
    });
}
```

## 注意事项

### 异步安全

1. **只读操作**：异步任务中只进行读取和计算，不修改实体状态
2. **主线程验证**：切回主线程后必须重新验证实体是否存在
3. **避免竞态条件**：主线程应用前再次检查染疫状态

### 性能优化

1. **批量处理**：一次异步任务处理多个区块
2. **限流控制**：避免单次处理过多实体
3. **配置缓存**：提前加载动物配置，避免重复查询

### 触发时机

建议在以下时机触发染疫判断：

1. **定时任务**：每 N 秒执行一次（可配置）
2. **动物繁殖时**：新生动物有一定概率染疫
3. **动物生成时**：自然生成的动物有基础概率染疫

## 架构映射

```
PlagueCheckScheduler (定时任务)
  ↓
PlagueCheckTask (异步任务)
  ↓
PlagueInfectionService (业务逻辑)
  ├─ PlagueFormulaService (公式计算)
  └─ AnimalDataService (数据管理)
      └─ AnimalDataDao (数据访问)
```
